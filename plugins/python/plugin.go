package python

import (
	"bytes"
	"fmt"
	"strings"

	"github.com/riceriley59/goanywhere/internal/core"
	"github.com/riceriley59/goanywhere/internal/core/factory"
)

// Ensure Plugin implements core.Plugin interface
var _ core.Plugin = (*Plugin)(nil)

func init() {
	factory.Register("python", func(verbose bool) core.Plugin {
		return NewPlugin(verbose)
	})
}

// Plugin implements the core.Plugin interface for Python ctypes
type Plugin struct {
	verbose bool
	mapper  *TypeMapper
	pkg     *core.ParsedPackage
}

// NewPlugin creates a new Python Plugin
func NewPlugin(verbose bool) *Plugin {
	return &Plugin{
		verbose: verbose,
	}
}

// Name returns the plugin name
func (a *Plugin) Name() string {
	return "python"
}

// Generate produces Python ctypes wrapper code for the given parsed package
func (a *Plugin) Generate(pkg *core.ParsedPackage) ([]byte, error) {
	a.pkg = pkg
	a.mapper = NewTypeMapper(pkg.Structs)

	var buf bytes.Buffer

	// Write header
	a.writeHeader(&buf)

	// Write library loader
	a.writeLibraryLoader(&buf)

	// Write function setup
	if err := a.writeSetupFunctions(&buf); err != nil {
		return nil, fmt.Errorf("failed to write setup functions: %w", err)
	}

	// Write helper functions
	a.writeHelpers(&buf)

	// Write function wrappers
	for _, fn := range pkg.Functions {
		if fn.IsVariadic {
			if a.verbose {
				fmt.Printf("Skipping variadic function: %s\n", fn.Name)
			}
			continue
		}
		if err := a.writeFunction(&buf, fn); err != nil {
			if a.verbose {
				fmt.Printf("Skipping function %s: %v\n", fn.Name, err)
			}
			continue
		}
	}

	// Write class wrappers for structs
	for _, st := range pkg.Structs {
		if err := a.writeClass(&buf, st); err != nil {
			if a.verbose {
				fmt.Printf("Skipping struct %s: %v\n", st.Name, err)
			}
			continue
		}
	}

	return buf.Bytes(), nil
}

// writeHeader writes the Python file header
func (a *Plugin) writeHeader(buf *bytes.Buffer) {
	buf.WriteString(`"""
Generated by goanywhere - Python ctypes bindings
Source: ` + a.pkg.Dir + `

This module provides Python bindings for the Go package using ctypes.
Requires the shared library to be built first using the CGO plugin.

Usage:
    from ` + a.pkg.Name + ` import *

    # Or specify library path:
    # import ` + a.pkg.Name + `
    # ` + a.pkg.Name + `.load_library("/path/to/lib` + a.pkg.Name + `.so")
"""

from __future__ import annotations
import ctypes
import os
import sys
from ctypes import (
    c_bool, c_char_p, c_double, c_float, c_void_p, c_size_t,
    c_int8, c_int16, c_int32, c_int64,
    c_uint8, c_uint16, c_uint32, c_uint64,
    c_longlong, c_ulonglong,
    POINTER, byref, cast,
)
from typing import Optional, Any, List

`)
}

// writeLibraryLoader writes the library loading code
func (a *Plugin) writeLibraryLoader(buf *bytes.Buffer) {
	buf.WriteString(`# Global library reference
_lib: Optional[ctypes.CDLL] = None

def load_library(path: Optional[str] = None) -> ctypes.CDLL:
    """
    Load the shared library.

    Args:
        path: Path to the shared library. If None, searches common locations.

    Returns:
        The loaded library.

    Raises:
        OSError: If the library cannot be found or loaded.
    """
    global _lib

    if _lib is not None and path is None:
        return _lib

    if path is not None:
        _lib = ctypes.CDLL(path)
        _setup_functions(_lib)
        return _lib

    # Search for library in common locations
    lib_name = "` + a.pkg.Name + `"
    search_paths = []

    # Current directory
    if sys.platform == "darwin":
        search_paths.append(f"./lib{lib_name}.dylib")
        search_paths.append(f"lib{lib_name}.dylib")
    elif sys.platform == "win32":
        search_paths.append(f"./{lib_name}.dll")
        search_paths.append(f"{lib_name}.dll")
    else:
        search_paths.append(f"./lib{lib_name}.so")
        search_paths.append(f"lib{lib_name}.so")

    # Directory of this Python file
    this_dir = os.path.dirname(os.path.abspath(__file__))
    if sys.platform == "darwin":
        search_paths.append(os.path.join(this_dir, f"lib{lib_name}.dylib"))
    elif sys.platform == "win32":
        search_paths.append(os.path.join(this_dir, f"{lib_name}.dll"))
    else:
        search_paths.append(os.path.join(this_dir, f"lib{lib_name}.so"))

    for lib_path in search_paths:
        try:
            _lib = ctypes.CDLL(lib_path)
            _setup_functions(_lib)
            return _lib
        except OSError:
            continue

    raise OSError(
        f"Could not find shared library. Searched: {search_paths}. "
        f"Build it first with: CGO_ENABLED=1 go build -buildmode=c-shared -o lib{lib_name}.so"
    )

def get_library() -> ctypes.CDLL:
    """Get the loaded library, loading it if necessary."""
    global _lib
    if _lib is None:
        load_library()
    return _lib

`)
}

// writeSetupFunctions writes the function signature setup
func (a *Plugin) writeSetupFunctions(buf *bytes.Buffer) error {
	buf.WriteString(`
def _setup_functions(lib: ctypes.CDLL) -> None:
    """Setup function signatures for type safety."""
    # Memory management
    lib.Free_String.argtypes = [c_void_p]  # Accept void pointer to preserve address
    lib.Free_String.restype = None
    lib.Free_Bytes.argtypes = [c_void_p]
    lib.Free_Bytes.restype = None

`)

	// Setup package functions
	for _, fn := range a.pkg.Functions {
		if fn.IsVariadic {
			continue
		}
		if err := a.writeFunctionSetup(buf, fn); err != nil {
			if a.verbose {
				fmt.Printf("Skipping function setup %s: %v\n", fn.Name, err)
			}
			continue
		}
	}

	// Setup struct functions
	for _, st := range a.pkg.Structs {
		a.writeStructSetup(buf, st)
	}

	buf.WriteString("\n")
	return nil
}

// writeFunctionSetup writes argtypes/restype for a function
func (a *Plugin) writeFunctionSetup(buf *bytes.Buffer, fn core.ParsedFunc) error {
	cFuncName := a.pkg.Name + "_" + fn.Name

	// Collect argtypes
	var argtypes []string
	var hasError bool

	for _, param := range fn.Params {
		pyType, err := a.mapper.MapType(param.Type)
		if err != nil {
			return err
		}
		argtypes = append(argtypes, pyType.CtypesType)
	}

	// Check for error return
	var returnType *core.ParsedType
	for _, result := range fn.Results {
		if result.Type.Kind == core.KindError {
			hasError = true
			argtypes = append(argtypes, "POINTER(c_char_p)")
		} else {
			returnType = &result.Type
		}
	}

	// Write argtypes
	fmt.Fprintf(buf, "    lib.%s.argtypes = [%s]\n", cFuncName, strings.Join(argtypes, ", "))

	// Write restype
	if returnType != nil {
		pyType, err := a.mapper.MapType(*returnType)
		if err != nil {
			return err
		}
		// Use CtypesReturnType if available (for strings), otherwise CtypesType
		restype := pyType.CtypesType
		if pyType.CtypesReturnType != "" {
			restype = pyType.CtypesReturnType
		}
		fmt.Fprintf(buf, "    lib.%s.restype = %s\n", cFuncName, restype)
	} else {
		fmt.Fprintf(buf, "    lib.%s.restype = None\n", cFuncName)
	}

	// Add blank line if there was an error param for readability
	if hasError {
		buf.WriteString("\n")
	}

	return nil
}

// writeStructSetup writes argtypes/restype for struct functions
func (a *Plugin) writeStructSetup(buf *bytes.Buffer, st core.ParsedStruct) {
	prefix := st.Name

	// Constructor
	fmt.Fprintf(buf, "    lib.%s_New.argtypes = []\n", prefix)
	fmt.Fprintf(buf, "    lib.%s_New.restype = c_size_t\n", prefix)

	// Destructor
	fmt.Fprintf(buf, "    lib.%s_Free.argtypes = [c_size_t]\n", prefix)
	fmt.Fprintf(buf, "    lib.%s_Free.restype = None\n", prefix)

	// Field getters/setters
	for _, field := range st.Fields {
		if !field.Exported {
			continue
		}

		pyType, err := a.mapper.MapType(field.Type)
		if err != nil {
			continue
		}

		// Getter - use CtypesReturnType if available
		restype := pyType.CtypesType
		if pyType.CtypesReturnType != "" {
			restype = pyType.CtypesReturnType
		}
		fmt.Fprintf(buf, "    lib.%s_Get%s.argtypes = [c_size_t]\n", prefix, field.Name)
		fmt.Fprintf(buf, "    lib.%s_Get%s.restype = %s\n", prefix, field.Name, restype)

		// Setter (skip for complex types)
		if !pyType.IsHandle && field.Type.Kind != core.KindSlice && field.Type.Kind != core.KindMap {
			fmt.Fprintf(buf, "    lib.%s_Set%s.argtypes = [c_size_t, %s]\n", prefix, field.Name, pyType.CtypesType)
			fmt.Fprintf(buf, "    lib.%s_Set%s.restype = None\n", prefix, field.Name)
		}
	}

	// Methods
	for _, method := range st.Methods {
		if method.IsVariadic {
			continue
		}

		cFuncName := prefix + "_" + method.Name

		// Collect argtypes (handle first)
		argtypes := []string{"c_size_t"}

		for _, param := range method.Params {
			pyType, err := a.mapper.MapType(param.Type)
			if err != nil {
				continue
			}
			argtypes = append(argtypes, pyType.CtypesType)
		}

		// Check for error return
		var returnType *core.ParsedType
		for _, result := range method.Results {
			if result.Type.Kind == core.KindError {
				argtypes = append(argtypes, "POINTER(c_char_p)")
			} else {
				returnType = &result.Type
			}
		}

		fmt.Fprintf(buf, "    lib.%s.argtypes = [%s]\n", cFuncName, strings.Join(argtypes, ", "))

		if returnType != nil {
			pyType, err := a.mapper.MapType(*returnType)
			if err != nil {
				fmt.Fprintf(buf, "    lib.%s.restype = None\n", cFuncName)
				continue
			}
			// Use CtypesReturnType if available
			restype := pyType.CtypesType
			if pyType.CtypesReturnType != "" {
				restype = pyType.CtypesReturnType
			}
			fmt.Fprintf(buf, "    lib.%s.restype = %s\n", cFuncName, restype)
		} else {
			fmt.Fprintf(buf, "    lib.%s.restype = None\n", cFuncName)
		}
	}

	buf.WriteString("\n")
}

// writeHelpers writes helper functions
func (a *Plugin) writeHelpers(buf *bytes.Buffer) {
	buf.WriteString(`
def _encode_string(s: str) -> bytes:
    """Encode a Python string to bytes for C."""
    if isinstance(s, bytes):
        return s
    return s.encode('utf-8')

def _decode_string(ptr: Optional[int]) -> Optional[str]:
    """Decode a C string pointer to a Python string."""
    if ptr is None or ptr == 0:
        return None
    # Cast void pointer to char pointer and decode
    return ctypes.cast(ptr, c_char_p).value.decode('utf-8')

def _check_error(error_ptr: ctypes.Array) -> None:
    """Check for and raise any error from a C function call."""
    # error_ptr is POINTER(c_char_p), we need to check the underlying pointer
    ptr_val = ctypes.cast(error_ptr, POINTER(c_void_p))[0]
    if ptr_val:
        error_msg = _decode_string(ptr_val)
        # Free the error string
        lib = get_library()
        lib.Free_String(ptr_val)
        raise RuntimeError(error_msg)

`)
}

// writeFunction writes a wrapper for a package-level function
func (a *Plugin) writeFunction(buf *bytes.Buffer, fn core.ParsedFunc) error {
	cFuncName := a.pkg.Name + "_" + fn.Name
	pyFuncName := toSnakeCase(fn.Name)

	// Collect parameter info
	var params []paramInfo
	var hasError bool

	for i, param := range fn.Params {
		pyType, err := a.mapper.MapType(param.Type)
		if err != nil {
			return err
		}
		name := param.Name
		if name == "" {
			name = fmt.Sprintf("arg%d", i)
		}
		params = append(params, paramInfo{
			name:   toSnakeCase(name),
			goType: param.Type,
			pyType: pyType,
		})
	}

	// Check for error return
	var returnType *core.ParsedResult
	for i, result := range fn.Results {
		if result.Type.Kind == core.KindError {
			hasError = true
		} else {
			returnType = &fn.Results[i]
		}
	}

	// Build function signature
	var typeHints []string
	for _, p := range params {
		typeHints = append(typeHints, fmt.Sprintf("%s: %s", p.name, p.pyType.PyType))
	}

	returnHint := "None"
	if returnType != nil {
		pyType, err := a.mapper.MapType(returnType.Type)
		if err != nil {
			return err
		}
		// For struct pointers, use the struct name as the type hint
		if pyType.IsHandle && returnType.Type.Kind == core.KindPointer && returnType.Type.ElemType != nil {
			returnHint = returnType.Type.ElemType.Name
		} else {
			returnHint = pyType.PyType
		}
	}

	// Write function
	fmt.Fprintf(buf, "\ndef %s(%s) -> %s:\n", pyFuncName, strings.Join(typeHints, ", "), returnHint)

	// Docstring
	if fn.Doc != "" {
		fmt.Fprintf(buf, "    \"\"\"%s\"\"\"\n", strings.TrimSpace(fn.Doc))
	}

	buf.WriteString("    lib = get_library()\n")

	// Convert input parameters
	for _, p := range params {
		if p.goType.Kind == core.KindString {
			fmt.Fprintf(buf, "    _%s = _encode_string(%s)\n", p.name, p.name)
		}
	}

	// Handle error out parameter
	if hasError {
		buf.WriteString("    _error = (c_char_p * 1)()\n")
	}

	// Build call arguments
	var callArgs []string
	for _, p := range params {
		if p.goType.Kind == core.KindString {
			callArgs = append(callArgs, "_"+p.name)
		} else if p.pyType.IsHandle {
			callArgs = append(callArgs, p.name+"._handle")
		} else {
			callArgs = append(callArgs, p.name)
		}
	}
	if hasError {
		callArgs = append(callArgs, "_error")
	}

	// Make the call
	if returnType != nil {
		fmt.Fprintf(buf, "    _result = lib.%s(%s)\n", cFuncName, strings.Join(callArgs, ", "))
	} else {
		fmt.Fprintf(buf, "    lib.%s(%s)\n", cFuncName, strings.Join(callArgs, ", "))
	}

	// Check error
	if hasError {
		buf.WriteString("    _check_error(_error)\n")
	}

	// Return result
	if returnType != nil {
		pyType, _ := a.mapper.MapType(returnType.Type)
		if returnType.Type.Kind == core.KindString {
			buf.WriteString("    _ret = _decode_string(_result)\n")
			buf.WriteString("    lib.Free_String(_result)\n")
			buf.WriteString("    return _ret\n")
		} else if pyType.IsHandle {
			// Get the class name (strip pointer prefix if present)
			className := returnType.Type.Name
			if returnType.Type.Kind == core.KindPointer && returnType.Type.ElemType != nil {
				className = returnType.Type.ElemType.Name
			}
			fmt.Fprintf(buf, "    return %s._from_handle(_result)\n", className)
		} else {
			buf.WriteString("    return _result\n")
		}
	}

	buf.WriteString("\n")
	return nil
}

// writeClass writes a wrapper class for a struct
func (a *Plugin) writeClass(buf *bytes.Buffer, st core.ParsedStruct) error {
	className := st.Name

	fmt.Fprintf(buf, "\nclass %s:\n", className)

	// Docstring
	if st.Doc != "" {
		fmt.Fprintf(buf, "    \"\"\"%s\"\"\"\n", strings.TrimSpace(st.Doc))
	} else {
		fmt.Fprintf(buf, "    \"\"\"Wrapper for Go %s struct.\"\"\"\n", st.Name)
	}

	// Constructor
	buf.WriteString(`
    def __init__(self):
        """Create a new instance."""
        lib = get_library()
        self._handle = lib.` + className + `_New()
        self._owned = True

    @classmethod
    def _from_handle(cls, handle: int) -> "` + className + `":
        """Create an instance from an existing handle."""
        instance = object.__new__(cls)
        instance._handle = handle
        instance._owned = False
        return instance

    def __del__(self):
        """Release the handle when garbage collected."""
        if hasattr(self, '_owned') and self._owned and hasattr(self, '_handle'):
            try:
                lib = get_library()
                lib.` + className + `_Free(self._handle)
            except:
                pass

    def close(self) -> None:
        """Explicitly release the handle."""
        if self._owned and self._handle:
            lib = get_library()
            lib.` + className + `_Free(self._handle)
            self._handle = 0
            self._owned = False

    def __enter__(self) -> "` + className + `":
        return self

    def __exit__(self, *args) -> None:
        self.close()

`)

	// Properties for exported fields
	for _, field := range st.Fields {
		if !field.Exported {
			continue
		}

		pyType, err := a.mapper.MapType(field.Type)
		if err != nil {
			if a.verbose {
				fmt.Printf("Skipping field %s.%s: %v\n", st.Name, field.Name, err)
			}
			continue
		}

		propName := toSnakeCase(field.Name)
		getFuncName := className + "_Get" + field.Name
		setFuncName := className + "_Set" + field.Name

		// Getter
		buf.WriteString("    @property\n")
		fmt.Fprintf(buf, "    def %s(self) -> %s:\n", propName, pyType.PyType)
		fmt.Fprintf(buf, "        \"\"\"Get %s.\"\"\"\n", field.Name)
		buf.WriteString("        lib = get_library()\n")

		if field.Type.Kind == core.KindString {
			fmt.Fprintf(buf, "        _result = lib.%s(self._handle)\n", getFuncName)
			buf.WriteString("        _ret = _decode_string(_result)\n")
			buf.WriteString("        lib.Free_String(_result)\n")
			buf.WriteString("        return _ret\n")
		} else {
			fmt.Fprintf(buf, "        return lib.%s(self._handle)\n", getFuncName)
		}
		buf.WriteString("\n")

		// Setter (skip for complex types)
		if !pyType.IsHandle && field.Type.Kind != core.KindSlice && field.Type.Kind != core.KindMap {
			fmt.Fprintf(buf, "    @%s.setter\n", propName)
			fmt.Fprintf(buf, "    def %s(self, value: %s) -> None:\n", propName, pyType.PyType)
			fmt.Fprintf(buf, "        \"\"\"Set %s.\"\"\"\n", field.Name)
			buf.WriteString("        lib = get_library()\n")

			if field.Type.Kind == core.KindString {
				buf.WriteString("        _value = _encode_string(value)\n")
				fmt.Fprintf(buf, "        lib.%s(self._handle, _value)\n", setFuncName)
			} else {
				fmt.Fprintf(buf, "        lib.%s(self._handle, value)\n", setFuncName)
			}
			buf.WriteString("\n")
		}
	}

	// Methods
	for _, method := range st.Methods {
		if method.IsVariadic {
			if a.verbose {
				fmt.Printf("Skipping variadic method: %s.%s\n", st.Name, method.Name)
			}
			continue
		}
		if err := a.writeMethod(buf, st, method); err != nil {
			if a.verbose {
				fmt.Printf("Skipping method %s.%s: %v\n", st.Name, method.Name, err)
			}
			continue
		}
	}

	return nil
}

// writeMethod writes a method wrapper
func (a *Plugin) writeMethod(buf *bytes.Buffer, st core.ParsedStruct, method core.ParsedMethod) error {
	cFuncName := st.Name + "_" + method.Name
	pyMethodName := toSnakeCase(method.Name)

	// Collect parameter info
	var params []paramInfo
	var hasError bool

	for i, param := range method.Params {
		pyType, err := a.mapper.MapType(param.Type)
		if err != nil {
			return err
		}
		name := param.Name
		if name == "" {
			name = fmt.Sprintf("arg%d", i)
		}
		params = append(params, paramInfo{
			name:   toSnakeCase(name),
			goType: param.Type,
			pyType: pyType,
		})
	}

	// Check for error return
	var returnType *core.ParsedResult
	for i, result := range method.Results {
		if result.Type.Kind == core.KindError {
			hasError = true
		} else {
			returnType = &method.Results[i]
		}
	}

	// Build method signature
	var typeHints []string
	typeHints = append(typeHints, "self")
	for _, p := range params {
		typeHints = append(typeHints, fmt.Sprintf("%s: %s", p.name, p.pyType.PyType))
	}

	returnHint := "None"
	if returnType != nil {
		pyType, err := a.mapper.MapType(returnType.Type)
		if err != nil {
			return err
		}
		// For struct pointers, use the struct name as the type hint
		if pyType.IsHandle && returnType.Type.Kind == core.KindPointer && returnType.Type.ElemType != nil {
			returnHint = returnType.Type.ElemType.Name
		} else {
			returnHint = pyType.PyType
		}
	}

	// Write method
	fmt.Fprintf(buf, "    def %s(%s) -> %s:\n", pyMethodName, strings.Join(typeHints, ", "), returnHint)

	// Docstring
	if method.Doc != "" {
		fmt.Fprintf(buf, "        \"\"\"%s\"\"\"\n", strings.TrimSpace(method.Doc))
	}

	buf.WriteString("        lib = get_library()\n")

	// Convert input parameters
	for _, p := range params {
		if p.goType.Kind == core.KindString {
			fmt.Fprintf(buf, "        _%s = _encode_string(%s)\n", p.name, p.name)
		}
	}

	// Handle error out parameter
	if hasError {
		buf.WriteString("        _error = (c_char_p * 1)()\n")
	}

	// Build call arguments
	var callArgs []string
	callArgs = append(callArgs, "self._handle")
	for _, p := range params {
		if p.goType.Kind == core.KindString {
			callArgs = append(callArgs, "_"+p.name)
		} else if p.pyType.IsHandle {
			callArgs = append(callArgs, p.name+"._handle")
		} else {
			callArgs = append(callArgs, p.name)
		}
	}
	if hasError {
		callArgs = append(callArgs, "_error")
	}

	// Make the call
	if returnType != nil {
		fmt.Fprintf(buf, "        _result = lib.%s(%s)\n", cFuncName, strings.Join(callArgs, ", "))
	} else {
		fmt.Fprintf(buf, "        lib.%s(%s)\n", cFuncName, strings.Join(callArgs, ", "))
	}

	// Check error
	if hasError {
		buf.WriteString("        _check_error(_error)\n")
	}

	// Return result
	if returnType != nil {
		pyType, _ := a.mapper.MapType(returnType.Type)
		if returnType.Type.Kind == core.KindString {
			buf.WriteString("        _ret = _decode_string(_result)\n")
			buf.WriteString("        lib.Free_String(_result)\n")
			buf.WriteString("        return _ret\n")
		} else if pyType.IsHandle {
			// Get the class name (strip pointer prefix if present)
			className := returnType.Type.Name
			if returnType.Type.Kind == core.KindPointer && returnType.Type.ElemType != nil {
				className = returnType.Type.ElemType.Name
			}
			fmt.Fprintf(buf, "        return %s._from_handle(_result)\n", className)
		} else {
			buf.WriteString("        return _result\n")
		}
	}

	buf.WriteString("\n")
	return nil
}

// paramInfo holds information about a function parameter
type paramInfo struct {
	name   string
	goType core.ParsedType
	pyType PyType
}

// toSnakeCase converts CamelCase to snake_case
func toSnakeCase(s string) string {
	var result []rune
	for i, r := range s {
		if i > 0 && r >= 'A' && r <= 'Z' {
			result = append(result, '_')
		}
		if r >= 'A' && r <= 'Z' {
			result = append(result, r+32) // lowercase
		} else {
			result = append(result, r)
		}
	}
	return string(result)
}
