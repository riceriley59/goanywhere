// Copyright 2026 Riley Rice
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package cgo

import (
	"bytes"
	"fmt"
	"os"
	"os/exec"
	"path/filepath"
	"runtime"
	"strings"
	"text/template"

	"github.com/riceriley59/goanywhere/internal/core"
	"github.com/riceriley59/goanywhere/internal/core/factory"
)

// Ensure Plugin implements core.Plugin interface
var _ core.Plugin = (*Plugin)(nil)

func init() {
	factory.Register("cgo", func(verbose bool) core.Plugin {
		return NewPlugin(verbose)
	})
}

// Plugin implements the core.Plugin interface for CGO
type Plugin struct {
	verbose bool
	mapper  *TypeMapper
	pkg     *core.ParsedPackage
}

// NewPlugin creates a new CGO Plugin
func NewPlugin(verbose bool) *Plugin {
	return &Plugin{
		verbose: verbose,
	}
}

// Name returns the plugin name
func (a *Plugin) Name() string {
	return "cgo"
}

// Generate produces CGO plugin code for the given parsed package
func (a *Plugin) Generate(pkg *core.ParsedPackage) ([]byte, error) {
	a.pkg = pkg
	a.mapper = NewTypeMapper(pkg.Structs)

	var buf bytes.Buffer

	// Write header
	if err := a.writeHeader(&buf); err != nil {
		return nil, fmt.Errorf("failed to write header: %w", err)
	}

	// Write handle registry
	if err := a.writeHandleRegistry(&buf); err != nil {
		return nil, fmt.Errorf("failed to write handle registry: %w", err)
	}

	// Write free functions
	if err := a.writeFreeFunctions(&buf); err != nil {
		return nil, fmt.Errorf("failed to write free functions: %w", err)
	}

	// Write function wrappers
	for _, fn := range pkg.Functions {
		if fn.IsVariadic {
			if a.verbose {
				fmt.Printf("Skipping variadic function: %s\n", fn.Name)
			}
			continue
		}
		if err := a.writeFunction(&buf, fn); err != nil {
			if a.verbose {
				fmt.Printf("Skipping function %s: %v\n", fn.Name, err)
			}
			continue
		}
	}

	// Write struct wrappers
	for _, st := range pkg.Structs {
		if err := a.writeStructWrapper(&buf, st); err != nil {
			if a.verbose {
				fmt.Printf("Skipping struct %s: %v\n", st.Name, err)
			}
			continue
		}
	}

	// Write main function (required for c-shared build mode)
	buf.WriteString("\n// Required for CGO shared library\nfunc main() {}\n")

	return buf.Bytes(), nil
}

// writeHeader writes the file header with imports and CGO directives
func (a *Plugin) writeHeader(buf *bytes.Buffer) error {
	tmpl := `// Code generated by goanywhere. DO NOT EDIT.
// source: {{.Dir}}

package main

/*
#include <stdlib.h>
#include <stdint.h>
#include <stdbool.h>
*/
import "C"
import (
	"sync"
	"unsafe"

	target "{{.ImportPath}}"
)

// Silence unused import warnings
var _ = unsafe.Pointer(nil)
var _ = target.{{.FirstExport}}

`
	t, err := template.New("header").Parse(tmpl)
	if err != nil {
		return err
	}

	// Find first exported symbol for import check
	firstExport := ""
	if len(a.pkg.Functions) > 0 {
		firstExport = a.pkg.Functions[0].Name
	} else if len(a.pkg.Structs) > 0 {
		firstExport = a.pkg.Structs[0].Name + "{}"
	}

	data := struct {
		Dir         string
		ImportPath  string
		FirstExport string
	}{
		Dir:         a.pkg.Dir,
		ImportPath:  a.pkg.ImportPath,
		FirstExport: firstExport,
	}

	return t.Execute(buf, data)
}

// writeHandleRegistry writes the handle management code
func (a *Plugin) writeHandleRegistry(buf *bytes.Buffer) error {
	code := `
// Handle registry for preventing GC of Go objects passed to C
var (
	handleMu      sync.RWMutex
	handleMap     = make(map[uintptr]interface{})
	handleCounter uintptr
)

func registerHandle(obj interface{}) C.uintptr_t {
	handleMu.Lock()
	defer handleMu.Unlock()
	handleCounter++
	handleMap[handleCounter] = obj
	return C.uintptr_t(handleCounter)
}

func getHandle(h C.uintptr_t) (interface{}, bool) {
	handleMu.RLock()
	defer handleMu.RUnlock()
	obj, ok := handleMap[uintptr(h)]
	return obj, ok
}

func freeHandle(h C.uintptr_t) {
	handleMu.Lock()
	defer handleMu.Unlock()
	delete(handleMap, uintptr(h))
}

`
	buf.WriteString(code)
	return nil
}

// writeFreeFunctions writes memory management functions
func (a *Plugin) writeFreeFunctions(buf *bytes.Buffer) error {
	code := `// ============ Memory Management ============

//export Free_String
func Free_String(s *C.char) {
	if s != nil {
		C.free(unsafe.Pointer(s))
	}
}

//export Free_Bytes
func Free_Bytes(data unsafe.Pointer) {
	if data != nil {
		C.free(data)
	}
}

`
	buf.WriteString(code)
	return nil
}

// writeFunction writes a single function adapter
func (a *Plugin) writeFunction(buf *bytes.Buffer, fn core.ParsedFunc) error {
	exportName := a.pkg.Name + "_" + fn.Name

	// Build parameter list
	var cParams []string
	var goArgs []string
	var conversions []string
	var hasError bool
	var errorIndex int

	for i, param := range fn.Params {
		ctype, err := a.mapper.MapType(param.Type)
		if err != nil {
			return err
		}

		paramName := param.Name
		if paramName == "" {
			paramName = fmt.Sprintf("arg%d", i)
		}

		cParams = append(cParams, fmt.Sprintf("%s %s", paramName, ctype.CTypeName))

		// Generate conversion
		goArg, conv := a.generateInputConversion(paramName, param.Type, ctype)
		goArgs = append(goArgs, goArg)
		if conv != "" {
			conversions = append(conversions, conv)
		}
	}

	// Check return types for error
	for i, result := range fn.Results {
		if result.Type.Kind == core.KindError {
			hasError = true
			errorIndex = i
			cParams = append(cParams, "outError **C.char")
		}
	}

	// Build return type
	var returnType string
	var returnConversion string
	nonErrorResults := make([]core.ParsedResult, 0)
	for i, result := range fn.Results {
		if i != errorIndex || !hasError {
			nonErrorResults = append(nonErrorResults, result)
		}
	}

	if len(nonErrorResults) == 0 {
		returnType = ""
	} else if len(nonErrorResults) == 1 {
		ctype, err := a.mapper.MapType(nonErrorResults[0].Type)
		if err != nil {
			return err
		}
		returnType = ctype.CTypeName
		returnConversion = a.generateOutputConversion("result", nonErrorResults[0].Type, ctype)
	} else {
		// Multiple return values - use out parameters
		for i, result := range nonErrorResults {
			ctype, err := a.mapper.MapType(result.Type)
			if err != nil {
				return err
			}
			name := result.Name
			if name == "" {
				name = fmt.Sprintf("out%d", i)
			}
			cParams = append(cParams, fmt.Sprintf("%s *%s", name, ctype.CTypeName))
		}
	}

	// Generate function body
	fmt.Fprintf(buf, "\n//export %s\n", exportName)
	if returnType != "" {
		fmt.Fprintf(buf, "func %s(%s) %s {\n", exportName, strings.Join(cParams, ", "), returnType)
	} else {
		fmt.Fprintf(buf, "func %s(%s) {\n", exportName, strings.Join(cParams, ", "))
	}

	// Write conversions
	for _, conv := range conversions {
		buf.WriteString("\t" + conv + "\n")
	}

	// Call the function
	if hasError {
		if len(nonErrorResults) == 1 {
			fmt.Fprintf(buf, "\tresult, err := target.%s(%s)\n", fn.Name, strings.Join(goArgs, ", "))
			buf.WriteString("\tif err != nil {\n")
			buf.WriteString("\t\t*outError = C.CString(err.Error())\n")
			fmt.Fprintf(buf, "\t\treturn %s\n", a.zeroValue(nonErrorResults[0].Type))
			buf.WriteString("\t}\n")
			buf.WriteString("\t*outError = nil\n")
			if returnConversion != "" {
				fmt.Fprintf(buf, "\treturn %s\n", returnConversion)
			} else {
				buf.WriteString("\treturn result\n")
			}
		} else if len(nonErrorResults) == 0 {
			fmt.Fprintf(buf, "\terr := target.%s(%s)\n", fn.Name, strings.Join(goArgs, ", "))
			buf.WriteString("\tif err != nil {\n")
			buf.WriteString("\t\t*outError = C.CString(err.Error())\n")
			buf.WriteString("\t\treturn\n")
			buf.WriteString("\t}\n")
			buf.WriteString("\t*outError = nil\n")
		}
	} else {
		if len(nonErrorResults) == 1 {
			fmt.Fprintf(buf, "\tresult := target.%s(%s)\n", fn.Name, strings.Join(goArgs, ", "))
			if returnConversion != "" {
				fmt.Fprintf(buf, "\treturn %s\n", returnConversion)
			} else {
				buf.WriteString("\treturn result\n")
			}
		} else if len(nonErrorResults) == 0 {
			fmt.Fprintf(buf, "\ttarget.%s(%s)\n", fn.Name, strings.Join(goArgs, ", "))
		}
	}

	buf.WriteString("}\n")
	return nil
}

// writeStructWrapper writes plugin code for a struct and its methods
func (a *Plugin) writeStructWrapper(buf *bytes.Buffer, st core.ParsedStruct) error {
	prefix := st.Name

	fmt.Fprintf(buf, "\n// ============ %s Struct ============\n", st.Name)

	// Write constructor
	fmt.Fprintf(buf, `
//export %s_New
func %s_New() C.uintptr_t {
	obj := &target.%s{}
	return registerHandle(obj)
}
`, prefix, prefix, st.Name)

	// Write destructor
	fmt.Fprintf(buf, `
//export %s_Free
func %s_Free(h C.uintptr_t) {
	freeHandle(h)
}
`, prefix, prefix)

	// Write field getters and setters for exported fields
	for _, field := range st.Fields {
		if !field.Exported {
			continue
		}

		ctype, err := a.mapper.MapType(field.Type)
		if err != nil {
			if a.verbose {
				fmt.Printf("Skipping field %s.%s: %v\n", st.Name, field.Name, err)
			}
			continue
		}

		// Getter
		getterConv := a.generateOutputConversion("obj."+field.Name, field.Type, ctype)
		fmt.Fprintf(buf, `
//export %s_Get%s
func %s_Get%s(h C.uintptr_t) %s {
	raw, ok := getHandle(h)
	if !ok {
		return %s
	}
	obj := raw.(*target.%s)
	return %s
}
`, prefix, field.Name, prefix, field.Name, ctype.CTypeName, a.zeroValue(field.Type), st.Name, getterConv)

		// Setter (skip for complex types that can't be easily set)
		if !ctype.IsHandle && field.Type.Kind != core.KindSlice && field.Type.Kind != core.KindMap {
			setterConv, _ := a.generateInputConversion("val", field.Type, ctype)
			fmt.Fprintf(buf, `
//export %s_Set%s
func %s_Set%s(h C.uintptr_t, val %s) {
	raw, ok := getHandle(h)
	if !ok {
		return
	}
	obj := raw.(*target.%s)
	obj.%s = %s
}
`, prefix, field.Name, prefix, field.Name, ctype.CTypeName, st.Name, field.Name, setterConv)
		}
	}

	// Write methods
	for _, method := range st.Methods {
		if method.IsVariadic {
			if a.verbose {
				fmt.Printf("Skipping variadic method: %s.%s\n", st.Name, method.Name)
			}
			continue
		}
		if err := a.writeMethod(buf, st, method); err != nil {
			if a.verbose {
				fmt.Printf("Skipping method %s.%s: %v\n", st.Name, method.Name, err)
			}
			continue
		}
	}

	return nil
}

// writeMethod writes a single method adapter
func (a *Plugin) writeMethod(buf *bytes.Buffer, st core.ParsedStruct, method core.ParsedMethod) error {
	exportName := st.Name + "_" + method.Name

	// Build parameter list (handle first, then method params)
	cParams := []string{"h C.uintptr_t"}
	var goArgs []string
	var conversions []string
	var hasError bool
	var errorIndex int

	for i, param := range method.Params {
		ctype, err := a.mapper.MapType(param.Type)
		if err != nil {
			return err
		}

		paramName := param.Name
		if paramName == "" {
			paramName = fmt.Sprintf("arg%d", i)
		}

		cParams = append(cParams, fmt.Sprintf("%s %s", paramName, ctype.CTypeName))

		goArg, conv := a.generateInputConversion(paramName, param.Type, ctype)
		goArgs = append(goArgs, goArg)
		if conv != "" {
			conversions = append(conversions, conv)
		}
	}

	// Check return types for error
	for i, result := range method.Results {
		if result.Type.Kind == core.KindError {
			hasError = true
			errorIndex = i
			cParams = append(cParams, "outError **C.char")
		}
	}

	// Build return type
	var returnType string
	var returnConversion string
	nonErrorResults := make([]core.ParsedResult, 0)
	for i, result := range method.Results {
		if i != errorIndex || !hasError {
			nonErrorResults = append(nonErrorResults, result)
		}
	}

	if len(nonErrorResults) == 0 {
		returnType = ""
	} else if len(nonErrorResults) == 1 {
		ctype, err := a.mapper.MapType(nonErrorResults[0].Type)
		if err != nil {
			return err
		}
		returnType = ctype.CTypeName
		returnConversion = a.generateOutputConversion("result", nonErrorResults[0].Type, ctype)
	}

	// Generate function body
	fmt.Fprintf(buf, "\n//export %s\n", exportName)
	if returnType != "" {
		fmt.Fprintf(buf, "func %s(%s) %s {\n", exportName, strings.Join(cParams, ", "), returnType)
	} else {
		fmt.Fprintf(buf, "func %s(%s) {\n", exportName, strings.Join(cParams, ", "))
	}

	// Get handle
	buf.WriteString("\traw, ok := getHandle(h)\n")
	buf.WriteString("\tif !ok {\n")
	if hasError {
		buf.WriteString("\t\t*outError = C.CString(\"invalid handle\")\n")
	}
	if returnType != "" {
		fmt.Fprintf(buf, "\t\treturn %s\n", a.zeroValue(nonErrorResults[0].Type))
	} else {
		buf.WriteString("\t\treturn\n")
	}
	buf.WriteString("\t}\n")
	fmt.Fprintf(buf, "\tobj := raw.(*target.%s)\n", st.Name)

	// Write conversions
	for _, conv := range conversions {
		buf.WriteString("\t" + conv + "\n")
	}

	// Call the method
	if hasError {
		if len(nonErrorResults) == 1 {
			fmt.Fprintf(buf, "\tresult, err := obj.%s(%s)\n", method.Name, strings.Join(goArgs, ", "))
			buf.WriteString("\tif err != nil {\n")
			buf.WriteString("\t\t*outError = C.CString(err.Error())\n")
			fmt.Fprintf(buf, "\t\treturn %s\n", a.zeroValue(nonErrorResults[0].Type))
			buf.WriteString("\t}\n")
			buf.WriteString("\t*outError = nil\n")
			if returnConversion != "" {
				fmt.Fprintf(buf, "\treturn %s\n", returnConversion)
			} else {
				buf.WriteString("\treturn result\n")
			}
		} else if len(nonErrorResults) == 0 {
			fmt.Fprintf(buf, "\terr := obj.%s(%s)\n", method.Name, strings.Join(goArgs, ", "))
			buf.WriteString("\tif err != nil {\n")
			buf.WriteString("\t\t*outError = C.CString(err.Error())\n")
			buf.WriteString("\t\treturn\n")
			buf.WriteString("\t}\n")
			buf.WriteString("\t*outError = nil\n")
		}
	} else {
		if len(nonErrorResults) == 1 {
			fmt.Fprintf(buf, "\tresult := obj.%s(%s)\n", method.Name, strings.Join(goArgs, ", "))
			if returnConversion != "" {
				fmt.Fprintf(buf, "\treturn %s\n", returnConversion)
			} else {
				buf.WriteString("\treturn result\n")
			}
		} else if len(nonErrorResults) == 0 {
			fmt.Fprintf(buf, "\tobj.%s(%s)\n", method.Name, strings.Join(goArgs, ", "))
		}
	}

	buf.WriteString("}\n")
	return nil
}

// generateInputConversion generates code to convert C input to Go
func (a *Plugin) generateInputConversion(name string, pt core.ParsedType, ct CType) (string, string) {
	switch pt.Kind {
	case core.KindString:
		goVar := "go" + capitalize(name)
		return goVar, fmt.Sprintf("%s := C.GoString(%s)", goVar, name)
	case core.KindPrimitive:
		return fmt.Sprintf("%s(%s)", pt.Name, name), ""
	case core.KindPointer:
		if ct.IsHandle {
			goVar := "go" + capitalize(name)
			elemType := pt.ElemType.Name
			return goVar, fmt.Sprintf("raw%s, _ := getHandle(%s); %s := raw%s.(*target.%s)", capitalize(name), name, goVar, capitalize(name), elemType)
		}
		return name, ""
	case core.KindStruct:
		if ct.IsHandle {
			goVar := "go" + capitalize(name)
			return goVar, fmt.Sprintf("raw%s, _ := getHandle(%s); %s := raw%s.(*target.%s)", capitalize(name), name, goVar, capitalize(name), pt.Name)
		}
		return name, ""
	default:
		return name, ""
	}
}

// generateOutputConversion generates code to convert Go output to C
func (a *Plugin) generateOutputConversion(expr string, pt core.ParsedType, ct CType) string {
	switch pt.Kind {
	case core.KindString:
		return fmt.Sprintf("C.CString(%s)", expr)
	case core.KindPrimitive:
		return fmt.Sprintf("%s(%s)", ct.CTypeName, expr)
	case core.KindPointer:
		if ct.IsHandle {
			return fmt.Sprintf("registerHandle(%s)", expr)
		}
		return expr
	case core.KindStruct:
		if ct.IsHandle {
			return fmt.Sprintf("registerHandle(&%s)", expr)
		}
		return expr
	default:
		return expr
	}
}

// zeroValue returns the zero value for a type in C
func (a *Plugin) zeroValue(pt core.ParsedType) string {
	switch pt.Kind {
	case core.KindString:
		return "nil"
	case core.KindPrimitive:
		if pt.Name == "bool" {
			return "false"
		}
		return "0"
	case core.KindPointer, core.KindStruct, core.KindSlice, core.KindMap:
		return "0"
	default:
		return "0"
	}
}

// capitalize capitalizes the first letter of a string
func capitalize(s string) string {
	if len(s) == 0 {
		return s
	}
	return strings.ToUpper(s[:1]) + s[1:]
}

// Build generates CGO code and compiles it to a shared library
func (a *Plugin) Build(pkg *core.ParsedPackage, inputPath string, opts *core.BuildOptions) error {
	// Generate CGO code
	if opts.Verbose {
		fmt.Println("Generating CGO wrapper code...")
	}
	code, err := a.Generate(pkg)
	if err != nil {
		return fmt.Errorf("generation error: %w", err)
	}

	// Write generated code
	cgoDir := filepath.Join(opts.OutputDir, "cgo_plugin")
	if err := os.MkdirAll(cgoDir, 0755); err != nil {
		return fmt.Errorf("cannot create cgo directory: %w", err)
	}

	cgoFile := filepath.Join(cgoDir, "main.go")
	if err := os.WriteFile(cgoFile, code, 0644); err != nil {
		return fmt.Errorf("write error: %w", err)
	}
	fmt.Printf("Generated CGO wrapper: %s\n", cgoFile)

	// Determine library name and extension
	libName := opts.LibraryName
	if libName == "" {
		libName = "lib" + pkg.Name
	}
	libExt := getSharedLibExtension()
	libFile := filepath.Join(opts.OutputDir, libName+libExt)

	// Build shared library
	if opts.Verbose {
		fmt.Printf("Building shared library: %s\n", libFile)
	}

	cmd := exec.Command("go", "build", "-buildmode=c-shared", "-o", libFile, cgoFile)
	cmd.Env = append(os.Environ(), "CGO_ENABLED=1")
	cmd.Stdout = os.Stdout
	cmd.Stderr = os.Stderr

	if err := cmd.Run(); err != nil {
		return fmt.Errorf("build failed: %w", err)
	}

	fmt.Printf("Built shared library: %s\n", libFile)

	// Note about header file
	headerFile := filepath.Join(opts.OutputDir, libName+".h")
	if _, err := os.Stat(headerFile); err == nil {
		fmt.Printf("Generated header file: %s\n", headerFile)
	}

	return nil
}

// getSharedLibExtension returns the platform-specific shared library extension
func getSharedLibExtension() string {
	switch runtime.GOOS {
	case "darwin":
		return ".dylib"
	case "windows":
		return ".dll"
	default:
		return ".so"
	}
}
